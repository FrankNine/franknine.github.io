1
00:00:00,166 --> 00:00:07,172
當物件被繪製到圖像，在每個像素上物件到攝影機的距離會被算成像素的 Z 深度

2
00:00:07,197 --> 00:00:08,826
值從 0.0 到 1.0

3
00:00:08,851 --> 00:00:10,961
舉例來說，我畫了個球

4
00:00:10,990 --> 00:00:14,999
在這個像素，我算出球面的深度是 0.6

5
00:00:15,079 --> 00:00:18,858
這個值會跟當下 Z 緩衝區的值作比較

6
00:00:18,938 --> 00:00:21,647
記得我們初始化會設定成全 1.0

7
00:00:21,672 --> 00:00:25,276
如果物件的距離比儲存的 Z 深度小

8
00:00:25,301 --> 00:00:30,625
則代表物件離攝影機較近，而物件的顏色應該被存到圖像的顏色緩衝區

9
00:00:30,680 --> 00:00:35,769
這個例子，球的深度明顯比 Z 深度暫存的最大深度 1.0 小

10
00:00:35,810 --> 00:00:37,878
所以是可見的

11
00:00:37,934 --> 00:00:42,546
假設我們再畫一個立方體，立方體在這個像素的深度是 0.3

12
00:00:42,577 --> 00:00:46,198
它比我們暫存的球體的 0.6 還小

13
00:00:46,222 --> 00:00:49,759
因為比較近，所以這個像素的顏色該被替換成立方體的顏色

14
00:00:49,784 --> 00:00:55,525
然後 0.3 的深度取代 0.6 的深度

15
00:00:55,550 --> 00:00:58,115
然後我們最後畫地平面

16
00:00:58,140 --> 00:01:01,567
地平面在這個像素的深度是 0.8

17
00:01:01,591 --> 00:01:04,696
這個值比現在的 Z 深度 0.3 大

18
00:01:04,720 --> 00:01:06,601
所以地平面沒有通過測試

19
00:01:06,602 --> 00:01:11,189
但這是理所當然的結果，因為地平面明顯比這兩個物件都遠

20
00:01:11,276 --> 00:01:16,460
這個流程的結果是深度依然是 0.3

21
00:01:16,500 --> 00:01:19,922
像素的顏色也依然是立方體的藍色

22
00:01:19,985 --> 00:01:22,489
也是最後顯示在螢幕上的顏色

23
00:01:22,577 --> 00:01:28,966
將每個像素的深度儲存起來，GPU 可以輕易地比較物件的遠近

24
00:01:28,991 --> 00:01:33,660
有趣的是數十年前 Z 緩衝區這個想法首次出現時

25
00:01:33,704 --> 00:01:38,902
大家認為它是個不切實際的昂貴做法，因為 Z 緩衝區需要許多記憶體

26
00:01:38,949 --> 00:01:44,476
你要幾 MB 的記憶體，在當時非常的貴

27
00:01:44,501 --> 00:01:47,187
所以這個演算法一開始是個餿主意

28
00:01:47,211 --> 00:01:49,658
然後記憶體變得便宜

29
00:01:49,695 --> 00:01:52,812
現在它是三角形柵格化的主流作法

