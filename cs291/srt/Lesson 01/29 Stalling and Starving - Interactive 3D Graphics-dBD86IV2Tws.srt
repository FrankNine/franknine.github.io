1
00:00:00,142 --> 00:00:05,436
在小考出現的管線裡，B 是最慢的階段

2
00:00:05,492 --> 00:00:07,553
我們稱 B 為瓶頸（Bottleneck）

3
00:00:07,598 --> 00:00:13,150
它是最慢的，也是決定管線效率的階段

4
00:00:13,198 --> 00:00:16,670
管線總是會有瓶頸，總有個最慢的階段

5
00:00:16,695 --> 00:00:20,745
也許有兩三個一樣慢，但總有最慢的

6
00:00:20,806 --> 00:00:24,060
3 跟 4 號物件繼續在管線移動

7
00:00:24,118 --> 00:00:27,121
而 B 階段還在處理 2 號物件

8
00:00:27,147 --> 00:00:33,307
當 C 等待輸入，但是沒有東西進來，因為 B 還沒完成

9
00:00:33,332 --> 00:00:38,758
這種情況叫飢餓（Starvation）
即 C 在 B 完成前不會有任何輸入

10
00:00:38,783 --> 00:00:43,271
另一方面，階段 A 已經處理完物件 1

11
00:00:43,301 --> 00:00:48,183
但是不能繼續因為階段 B 還在處理物件 2

12
00:00:48,208 --> 00:00:49,791
這個叫作停頓（Stalling）

13
00:00:49,816 --> 00:00:52,995
同樣的原則也適用於繪圖管線

14
00:00:53,020 --> 00:00:57,953
讓應用程式跑得夠有效率使 GPU 一直有資料可處理是種常見瓶頸出現之處

15
00:00:58,010 --> 00:01:02,686
瓶頸會隨時間改變，有時這階段比較慢、有時另一階段比較慢

16
00:01:02,724 --> 00:01:07,718
GPU 設計者使用各種技術來平衡負載，像是先進先出的佇列

17
00:01:07,743 --> 00:01:11,319
在前面的階段儲備一些物件

18
00:01:11,383 --> 00:01:15,102
如果慢的階段突然變快，這些物件可以快速通過

19
00:01:15,158 --> 00:01:18,024
或是其它技術像是統一 Shader（Unified Shader）

20
00:01:18,080 --> 00:01:21,267
在這門課我們不會深究細節

21
00:01:21,292 --> 00:01:24,559
但是大概知道 GPU 內有很多複雜的運作機制是好的

22
00:01:24,584 --> 00:01:28,483
各式效能除錯工具讓你找出管線哪個階段是瓶頸

23
00:01:28,508 --> 00:01:31,693
以幫助你改善程式的效能

