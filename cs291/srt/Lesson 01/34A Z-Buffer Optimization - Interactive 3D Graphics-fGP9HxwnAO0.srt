1
00:00:00,134 --> 00:00:03,809
答案跟 Z 深度比較結果有關

2
00:00:03,847 --> 00:00:08,622
當物件比 Z 緩衝區儲存的深度小（較近）時，需要 3 個週期

3
00:00:08,677 --> 00:00:13,288
讀取舊的 Z 深度、寫入新的 Z 深度、寫入新的顏色

4
00:00:13,328 --> 00:00:17,261
我們將新的值稱為來源（Source），舊的值稱為目標（Destination）

5
00:00:17,333 --> 00:00:20,429
當物件較遠時，我們只需要 1 週期

6
00:00:20,478 --> 00:00:24,282
我們總是會有讀取 Z 緩衝區（目標）的消耗

7
00:00:24,358 --> 00:00:27,499
當我們比較來源與目標，需要 3 週期

8
00:00:27,554 --> 00:00:32,974
因為這邊需要替換舊的顏色與深度

9
00:00:33,053 --> 00:00:37,507
然而如果來源的深度值比目標的大

10
00:00:37,532 --> 00:00:39,390
那就結束了，因為物件不可見

11
00:00:39,415 --> 00:00:42,924
我們不需要作後續處理，所以只要 1 週期

12
00:00:42,948 --> 00:00:45,118
我們倒著來看各選項

13
00:00:45,222 --> 00:00:48,183
從後到前的順序是最糟的

14
00:00:48,247 --> 00:00:51,439
因為各個物件會依序變成最近的物件

15
00:00:51,464 --> 00:00:54,131
每次讀取 Z 緩衝區後都要跟著寫入

16
00:00:54,156 --> 00:00:57,977
隨機順序也許可以避開最糟狀況，但不是最快的

17
00:00:58,002 --> 00:01:02,525
從大到小的效果不可預見，因為比較是發生在各像素

18
00:01:02,549 --> 00:01:04,152
物件的大小沒有直接相關

19
00:01:04,153 --> 00:01:06,334
第一個選項是對的

20
00:01:06,359 --> 00:01:12,626
應用程式可以替 GPU 概略地排出前到後的順序來最佳化

