1
00:00:00,015 --> 00:00:04,277
回到繪圖管線，簡化的概觀像這樣

2
00:00:04,302 --> 00:00:07,166
應用程式將三角形送往 GPU

3
00:00:07,191 --> 00:00:12,109
GPU 算出頂點在螢幕上的位置還有 Z 深度

4
00:00:12,133 --> 00:00:14,449
三角形內的每個像素都會被上色

5
00:00:14,474 --> 00:00:20,081
如果像素通過 Z 深度測試，則會被存到圖像，在每格結束時顯示到螢幕

6
00:00:20,106 --> 00:00:23,296
現代 GPU 的管線有部分是可程式的

7
00:00:23,321 --> 00:00:27,939
座標轉換到螢幕系統是由 Vertex Shader 完成的

8
00:00:27,964 --> 00:00:30,810
這個可程式元件，可以算是微型電腦

9
00:00:30,834 --> 00:00:33,668
處理三角形上的各個頂點

10
00:00:33,693 --> 00:00:39,572
Vertex Shader 使用提供給它的資訊來操作各個頂點

11
00:00:39,597 --> 00:00:43,605
舉例來說，三角形某個頂點的顏色可能是用算的

12
00:00:43,629 --> 00:00:46,098
或是修改頂點位置

13
00:00:46,123 --> 00:00:49,235
像是製造物件膨脹或爆破的效果

14
00:00:49,260 --> 00:00:54,688
Vertex Shader 一定會做的是輸出頂點在螢幕上的位置

15
00:00:54,713 --> 00:00:58,917
現代 GPU 管線的後半由兩個階段構成

16
00:00:58,942 --> 00:01:01,412
三角形設定（Triangle Setup）跟 Fragment Shader

17
00:01:01,437 --> 00:01:07,020
三角形設定使用 Vertex Shader 給的螢幕上三個點構成三角形

18
00:01:07,045 --> 00:01:09,082
結果是一個螢幕空間的三角形

19
00:01:09,107 --> 00:01:13,404
每個跟三角形有重疊的像素都會產生一個所謂的 Fragment

20
00:01:13,429 --> 00:01:15,866
這個過程叫做掃瞄轉換（Scan Conversion）

21
00:01:15,890 --> 00:01:18,505
產生的 Fragment 被送往 Fragment Shader

22
00:01:18,530 --> 00:01:23,581
如果你用的是微軟的 DirectX API，則這個被稱作 Pixel Shader

23
00:01:23,606 --> 00:01:27,614
Fragment Shader 會收到被處理過的三角形資訊

24
00:01:27,639 --> 00:01:31,907
跟 Vertex Shader 類似，程式設計師可以再傳入額外的資料

25
00:01:31,932 --> 00:01:36,067
Fragment Shader 執行一段程式通常會輸出顏色與 Z 深度

26
00:01:36,092 --> 00:01:39,777
這個 Z 深度會拿去跟 Z 緩衝區的值做比較

27
00:01:39,802 --> 00:01:43,175
如果表面可見，則該像素的顏色會被存下來

28
00:01:43,200 --> 00:01:47,297
Shader 管線設計上會計算表面涵蓋的所有像素的顏色

29
00:01:47,322 --> 00:01:50,016
這是最終的目標：產生圖像

30
00:01:50,041 --> 00:01:54,480
管線所做的一切都是為了「如何有效率地計算這個顏色」

31
00:01:54,505 --> 00:01:57,848
這是這單元後半的重點：材質跟其運作原理

32
00:01:57,873 --> 00:02:02,142
給定材質與入射光，要求材質所產生的顏色

