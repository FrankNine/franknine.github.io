1
00:00:00,015 --> 00:00:04,744
大致由後往前排序物件還有更多問題

2
00:00:04,769 --> 00:00:09,399
像是透明物件的背面沒有顯示出來

3
00:00:09,424 --> 00:00:13,814
如果你把背面顯示打開，會看到奇怪的繪圖假影

4
00:00:13,839 --> 00:00:18,572
有幾個背面會在正面之前畫然後混色，有些不會

5
00:00:18,596 --> 00:00:20,462
給我們一格一格的效果

6
00:00:20,487 --> 00:00:26,414
舉例來說，這是一個方塊的側面透視，上面是面繪製的順序

7
00:00:26,439 --> 00:00:30,584
1 號面最先畫，2 號跟它混色

8
00:00:30,609 --> 00:00:35,427
3 號面畫的時候填入 Z 緩衝區並跟 1 號面混色

9
00:00:35,451 --> 00:00:39,856
4 號面在 3 號之後，所以繪圖時不可見

10
00:00:39,881 --> 00:00:45,553
兩個背面變成只有 1 號對最後成像有作用

11
00:00:45,578 --> 00:00:48,611
即使打開背面剔除，排序也對

12
00:00:48,635 --> 00:00:51,866
面對大小不同的物體還是會遇到問題

13
00:00:51,891 --> 00:00:56,614
假設有一片地面跟一個紅色物體停在上面，兩者都透明

14
00:00:56,639 --> 00:01:03,290
因為地面的中心點離攝影機較近，照排序會比紅色物件晚畫

15
00:01:03,315 --> 00:01:08,082
這樣會讓地面看起來在物件之上

16
00:01:08,106 --> 00:01:10,471
這裡還有一個問題

17
00:01:10,496 --> 00:01:15,196
複雜的物件可能在同一像素上有兩個以上的面重疊

18
00:01:15,221 --> 00:01:18,926
螢幕上顯示的還是取決於繪圖順序

19
00:01:18,951 --> 00:01:25,069
如果左邊的 Fragment 先畫，則右邊的 Fragment 在這個像素上的混色會錯

20
00:01:25,094 --> 00:01:29,644
有些研究在探討如何排序網格的三角形來迴避問題

21
00:01:29,669 --> 00:01:32,784
但這些技巧可能太過昂貴

22
00:01:32,809 --> 00:01:37,199
你現在可能對正確繪製透明感到絕望

23
00:01:37,223 --> 00:01:40,161
Z 緩衝區本身設計就只儲存最近的一個物件

24
00:01:40,186 --> 00:01:45,754
除非你能保證像素上的物件的順序正確，否則沒什麼能做的

25
00:01:45,779 --> 00:01:49,737
還有只讀不寫 Z 緩衝區的技巧

26
00:01:49,762 --> 00:01:52,401
但沒有完美的解法

27
00:01:52,426 --> 00:01:58,396
如果你很想要對的結果，有一種做法叫深度剝除（Depth Peeling）

28
00:01:58,421 --> 00:02:03,331
想法是一層一層剝除透明物件，直到每一層都被處理過

29
00:02:03,356 --> 00:02:06,782
剝除藉由在每個像素上儲存最小 Z 深度完成

30
00:02:06,807 --> 00:02:12,785
舉例來說，第一層是所有最靠近攝影機的透明面

31
00:02:12,809 --> 00:02:16,077
第二層是第二靠近的面

32
00:02:16,102 --> 00:02:21,264
第三第四層接著剝出，直到整個物件都被繪製過

33
00:02:21,289 --> 00:02:22,958
這是這個做法的概念

34
00:02:22,983 --> 00:02:26,207
參考課程資料以獲得更多關於這個演算法的知識

35
00:02:26,232 --> 00:02:31,616
缺點是每剝出一層透明物件就要繪製一次

36
00:02:31,641 --> 00:02:35,765
要找到所有層並正確繪製可能需要很多輪

37
00:02:35,790 --> 00:02:43,378
透明問題的終極解法是儲存像素上所有透明 Fragment 與其深度的清單

38
00:02:43,403 --> 00:02:46,235
這種做法叫做 A 緩衝區（A Buffer）

39
00:02:46,260 --> 00:02:50,928
當我們取得所有資訊，便能用正確順序合併 Fragment

40
00:02:50,953 --> 00:02:57,460
新的電腦 GPU 能這樣做，但是記憶體消耗會大增

41
00:02:57,485 --> 00:03:02,555
有趣的是手機使用另一種叫做 Tile-based 的架構

42
00:03:02,580 --> 00:03:05,450
更容易保存這樣的 Fragment 清單

43
00:03:05,475 --> 00:03:08,775
還有一種叫做隨機式透明（Stochastic Transparency）的作法

44
00:03:08,800 --> 00:03:15,524
在像素內進行紗門透明再加入隨機以取得合理的平均結果

45
00:03:15,549 --> 00:03:20,101
繞了一圈又回到我第一個提的透明演算法

46
00:03:20,126 --> 00:03:22,644
這問題在 GPU 上沒有簡單答案

