1
00:00:00,001 --> 00:00:02,817
我們來看看簡單的階層結構如何運作

2
00:00:02,842 --> 00:00:06,725
我做了一個有兩部分的機械手臂，前臂與上臂

3
00:00:06,750 --> 00:00:12,932
這算是經典的圖學範例，但我的手臂會是 T-850

4
00:00:12,956 --> 00:00:15,886
前臂是這塊，由六個物件構成

5
00:00:15,911 --> 00:00:17,990
我做了些測試，結果不錯

6
00:00:18,015 --> 00:00:22,214
我讓連接上臂的位置落在原點

7
00:00:22,239 --> 00:00:28,563
因為我知道當施加旋轉時，是繞著原點轉動的

8
00:00:28,588 --> 00:00:30,891
這是創造前臂的程式

9
00:00:30,916 --> 00:00:34,301
沒有什麼特別的，我創造了一個 Object3D

10
00:00:34,326 --> 00:00:39,809
呼叫 createRobotExtender，然後將前臂加入場景，這樣我才看得到

11
00:00:39,834 --> 00:00:45,059
我的 createRobotExtender 函式將一群幾何物件加到前臂物件裡

12
00:00:45,084 --> 00:00:49,194
傳入 faLength 參數告訴函式前臂要伸展多高

13
00:00:49,219 --> 00:00:52,049
我在前臂加入什麼不重要

14
00:00:52,074 --> 00:00:59,423
重要的是我加入的物件都會繞著原點轉

15
00:00:59,448 --> 00:01:03,263
我用差不多方式設計與撰寫上臂的程式

16
00:01:03,288 --> 00:01:05,397
它一樣是繞著原點轉

17
00:01:05,422 --> 00:01:11,443
我們在意的是這兩個物件如何鉤在一起，使前臂成為上臂的子物件

18
00:01:11,468 --> 00:01:14,408
這段程式將兩個物件連接在一起

19
00:01:14,433 --> 00:01:17,114
像以前一樣創造手臂的兩段

20
00:01:17,139 --> 00:01:22,923
關鍵的不同是不把前臂直接加到場景，而是加到上臂

21
00:01:22,948 --> 00:01:25,893
我們也移動前臂到上臂的頂端

22
00:01:25,918 --> 00:01:31,849
現在上臂能移動、旋轉、縮放，而它的零件會受到相同的座標變換

23
00:01:31,874 --> 00:01:35,633
所以我將物件重新命名為「手臂」取代前臂

24
00:01:35,658 --> 00:01:38,970
因為它實際上包含了上臂與前臂

25
00:01:38,995 --> 00:01:43,572
像是如果我們設定手臂的旋轉，整個物件都會旋轉

26
00:01:43,597 --> 00:01:48,922
要認知到的是手臂本身不瞭解或關心子物件包含的東西

27
00:01:48,947 --> 00:01:52,846
當我將前臂加入手臂時，前臂就成為了手臂的一部分

28
00:01:52,871 --> 00:01:55,739
跟加入一個球或方塊一樣

29
00:01:55,764 --> 00:02:02,190
但因為我們能藉由座標變換控制任何物件，我們能改變前臂的位置

30
00:02:02,215 --> 00:02:07,385
像是這段程式改變前臂的旋轉，不會影響到其他物件

31
00:02:07,410 --> 00:02:13,027
座標變換的順序是前臂的旋轉、平移接著是手臂的旋轉與平移

32
00:02:13,052 --> 00:02:18,085
前臂能任意移動而不需要知道手臂整體的狀態

33
00:02:18,110 --> 00:02:20,455
手臂的座標變換之後才會施加上去

34
00:02:20,480 --> 00:02:25,183
試試展示看兩個部位如何受到不同控制的影響

