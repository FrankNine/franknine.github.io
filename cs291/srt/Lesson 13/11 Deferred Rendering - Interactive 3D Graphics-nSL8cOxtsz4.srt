1
00:00:00,001 --> 00:00:03,015
在場景裡加越來越多的光會有計算成本的問題

2
00:00:03,040 --> 00:00:06,582
每加一盞光就是所有表面都要計算這盞光的作用

3
00:00:06,607 --> 00:00:08,845
一種解法是 Deferred Rendering

4
00:00:08,870 --> 00:00:12,944
看看這個展示，裡面有 50 盞光，跑起來完全沒問題

5
00:00:12,969 --> 00:00:18,092
通常你在像素上儲存最接近可見的物件表面計算出來的 Fragment 顏色

6
00:00:18,117 --> 00:00:20,050
這通常稱作 Forward Rendering

7
00:00:20,075 --> 00:00:24,066
在 Deferred Rendering 演算法，你在像素上儲存的是資料

8
00:00:24,091 --> 00:00:28,052
有許多變體如 Deferred Shading 跟 Deferred Lighting

9
00:00:28,076 --> 00:00:29,214
這是其中一種

10
00:00:29,239 --> 00:00:34,480
你可以儲存像素上最接近的表面的位置、法向量、材質顏色跟閃亮程度

11
00:00:34,505 --> 00:00:36,463
也跟以前一樣畫到 Z 緩衝區

12
00:00:36,488 --> 00:00:39,993
我不會解釋要如何儲存這些資料

13
00:00:40,018 --> 00:00:44,074
重點是知道做得到，這只是圖像資料的另一種格式

14
00:00:44,099 --> 00:00:48,887
Deferred Rendering 裡每個點光源都有距離上限

15
00:00:48,912 --> 00:00:50,687
這段距離形成一個球

16
00:00:50,712 --> 00:00:53,450
每個光源都用特別方法畫一顆球

17
00:00:53,475 --> 00:00:57,043
換種說法是每盞光能影響一定的空間

18
00:00:57,068 --> 00:01:00,427
在球的範圍內的表面就會受光影響

19
00:01:00,452 --> 00:01:06,108
每盞光只影響螢幕上一小部分的像素，即光的球體包含的區域

20
00:01:06,108 --> 00:01:10,430
代表我們能計算大量範圍有限的光源

21
00:01:10,455 --> 00:01:16,070
畫這個球，我們告訴 GPU 哪些像素被光涵蓋，應該計算光照

22
00:01:16,095 --> 00:01:20,065
偵測的形狀有許多變體，像是圓、對齊螢幕的長方形

23
00:01:20,090 --> 00:01:26,521
不管是什麼形狀，這個幾何的作用在測試出可能在光源範圍內的像素有限集合

24
00:01:26,546 --> 00:01:31,551
這跟標準打光不同，標準打光每個像素上所有的表面都計算每盞光的作用

25
00:01:31,576 --> 00:01:34,244
我希望這樣能讓你大致了解 Deferred Rendering 如何運作

26
00:01:34,269 --> 00:01:37,912
我其實往前跳太多了，你要懂 Shader 程式才能實作這些繪圖方式

27
00:01:37,937 --> 00:01:43,683
基本概念是在記錄所有物件表面資料後把光當成物件畫進場景

28
00:01:43,708 --> 00:01:47,595
Deferred Rendering 有些缺陷，像是無法處理透明

29
00:01:47,620 --> 00:01:50,603
但它提供了在場景內加入極大量光的方法

