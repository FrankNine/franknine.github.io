1
00:00:00,001 --> 00:00:03,308
到目前為止我們檢視的都是局部照明（Local Illumination）模型

2
00:00:03,333 --> 00:00:06,526
物件受光影響，其結果直接送往眼睛

3
00:00:06,551 --> 00:00:11,249
光只來自光源，沒有光從別的物件反射而來

4
00:00:11,274 --> 00:00:13,844
有更多光的路徑可以追蹤

5
00:00:13,869 --> 00:00:17,173
一種可以模擬這個現象繪圖方式叫做光線追蹤（Ray Tracing）

6
00:00:17,198 --> 00:00:21,946
我們見識過 GPU 如何將物件三角形送往螢幕柵格化

7
00:00:21,971 --> 00:00:25,299
光線追蹤則是從眼透過各個像素射出射線

8
00:00:25,324 --> 00:00:32,290
物件跟射線做交叉測試，路徑上最接近的物件被拿來計算射線的顏色貢獻

9
00:00:32,315 --> 00:00:35,726
你可以想像每個射線都在繪製 1 X 1 像素

10
00:00:35,751 --> 00:00:40,970
尋找該像素上最接近物件的方法之一是把所有三角形送進管線柵格化

11
00:00:40,995 --> 00:00:43,628
用 Z 緩衝區紀錄最近的物件

12
00:00:43,653 --> 00:00:47,079
這可能是最沒效率的光線追蹤做法

13
00:00:47,104 --> 00:00:52,086
實務上，研究與實務人員花了大量心力改進演算法

14
00:00:52,111 --> 00:00:54,638
目的是要更快找到射線上最近的物件

15
00:00:54,663 --> 00:00:59,886
柵格化一部分的速度優勢來自同一三角形通常會覆蓋多個像素

16
00:00:59,911 --> 00:01:03,268
許多中間計算結果在處理三角形時可以共享

17
00:01:03,293 --> 00:01:06,898
最簡單的形態下光線追蹤可以給我們柵格化的結果

18
00:01:06,923 --> 00:01:09,655
每條從眼出發的射線找到沿著射線最接近的物件

19
00:01:09,680 --> 00:01:13,084
光在表面上的作用被計算出來然後顯示

20
00:01:13,109 --> 00:01:15,863
但這只是光線追蹤的起點

21
00:01:15,888 --> 00:01:22,697
光到表面的路徑上，我們在基礎柵格化做了簡化：物件不相互遮擋

22
00:01:22,722 --> 00:01:24,754
換句話說，不投射陰影

23
00:01:24,779 --> 00:01:28,933
在光線追蹤裡加入影子很簡單，從表面再射一條射線道光源

24
00:01:28,958 --> 00:01:31,796
如果遇到阻礙，就直接忽略這盞光

25
00:01:31,821 --> 00:01:38,725
因為計算都是發生在世界坐標系，我們可以迴避柵格化中許多精確度問題，像是 Shadow Mapping

26
00:01:38,750 --> 00:01:43,802
光線追蹤也能提供真實的玻璃反射

27
00:01:43,827 --> 00:01:47,322
閃亮的表面可以再往反射方向打一條射線

28
00:01:47,347 --> 00:01:53,436
這條射線打到的就是表面該反射的東西，可以加入最終顏色計算，即其輻射率

29
00:01:53,461 --> 00:01:55,489
假設這顆球是玻璃

30
00:01:55,514 --> 00:01:59,785
我們可以取代單純的顏色過濾，改生成折射方向射線看看會打到什麼

31
00:01:59,810 --> 00:02:04,781
當它打到球的另一面要離開時，我們再生成一條折射一條反射射線

32
00:02:04,806 --> 00:02:07,341
我們能一直產生射線，直到某個上限

