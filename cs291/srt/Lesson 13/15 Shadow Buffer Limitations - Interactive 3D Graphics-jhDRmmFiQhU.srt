1
00:00:00,015 --> 00:00:03,967
仔細觀察模型的腳，我預期你會發現一些奇怪的著色

2
00:00:03,992 --> 00:00:06,810
如果你將聚光燈加亮，效果會更明顯

3
00:00:06,835 --> 00:00:09,834
移動聚光燈可能會跟著移動這些紋路

4
00:00:09,859 --> 00:00:13,378
Shadow Mapping 演算法是由光的角度看世界

5
00:00:13,403 --> 00:00:16,246
然後在正常繪圖時查找這張產生的深度影像

6
00:00:16,271 --> 00:00:21,344
表面的深度跟座標變換後的 Shadow Map 深度做比較

7
00:00:21,369 --> 00:00:23,024
這是一切問題的根源

8
00:00:23,049 --> 00:00:27,769
光的成像上的像素跟攝影機角度的像素不會完美對齊

9
00:00:27,794 --> 00:00:30,271
這會產生所謂的 Surface Acne

10
00:00:30,296 --> 00:00:33,729
在應該被完全照明的範圍出現黑點或黑塊

11
00:00:33,754 --> 00:00:39,027
舉這個例子，以光的角度表面距離 3.80 米

12
00:00:39,052 --> 00:00:43,563
但從攝影機的角度算出表面距離光 3.81 米

13
00:00:43,588 --> 00:00:48,407
因為這個值微微高過光的角度的值，這個表面被認為在影子中

14
00:00:48,432 --> 00:00:51,756
這不應該發生的，這個表面遮蔽了自己

15
00:00:51,781 --> 00:00:54,599
因為深度的比較不如我們希望的精確

16
00:00:54,624 --> 00:00:57,397
這個展示展現了問題跟治標方法

17
00:00:57,422 --> 00:01:01,482
在表面上你能看到 Acne 紋路，即幾何自我遮蔽的範圍

18
00:01:01,507 --> 00:01:05,267
一種作法是加入容錯值，叫做 Shadow Bias

19
00:01:05,292 --> 00:01:11,571
如果攝影機計算出對光的深度加上這個值小於從光算出的深度，則認定表面被照亮

20
00:01:11,596 --> 00:01:15,245
不幸的是加入容錯值會產生另外叫彼得潘（Peter Panning）的問題

21
00:01:15,270 --> 00:01:19,361
就像彼得潘的故事，物件會開始看起來好像跟影子分離

22
00:01:19,386 --> 00:01:22,071
有時看起來好像在漂浮

23
00:01:22,096 --> 00:01:27,246
在這個演算法存在的 35 年間，有許多改良方法被提出

24
00:01:27,271 --> 00:01:31,214
Shadow Mapping 還有其他問題，像是影子邊緣看起來一格一格的

25
00:01:31,239 --> 00:01:35,052
有 Percentage Cluster Filtering 和 Cascaded Shadow Maps 等解法

26
00:01:35,077 --> 00:01:39,484
我不會解釋原理，只是想提 Three.js 有內建這些算法

