1
00:00:00,001 --> 00:00:05,570
一種追蹤光線從各式路徑抵達眼睛的方法是在各像素射出更多射線

2
00:00:05,595 --> 00:00:07,994
讓它們在場景裡彈射，希望它們能找到光源

3
00:00:08,019 --> 00:00:09,526
這叫做路徑追蹤（Path Tracing）

4
00:00:09,551 --> 00:00:13,179
一開始的成像雜訊很多，但時間夠久結果會是正確的

5
00:00:13,204 --> 00:00:17,783
這是 Evan Wallace 在 WebGL 製作的即時展示，我建議你自己試試

6
00:00:17,808 --> 00:00:21,740
注意到光從牆面彈到球上的滲色（Color Bleeding）效果

7
00:00:21,765 --> 00:00:26,471
你也能在物件上製造有點霧面的反射，取代傳統光線追蹤的清晰反射

8
00:00:26,496 --> 00:00:29,068
這個展示用了漸進式繪圖（Progressive Rendering）

9
00:00:29,093 --> 00:00:32,408
持續從像素往場景發射射線然後不斷混合結果

10
00:00:32,433 --> 00:00:34,752
等越久成像會越好

11
00:00:34,776 --> 00:00:37,542
你甚至能用路徑追蹤繪製《Minecraft》場景

12
00:00:37,567 --> 00:00:41,801
這是我用免費的 Chunky 路徑追蹤程式產生的，場景中有光柱效果

13
00:00:41,826 --> 00:00:44,724
基本的路徑追蹤程式還蠻好寫的

14
00:00:44,749 --> 00:00:49,146
基本上就是往合理方向打很多射線然後加總所有找到的光

15
00:00:49,171 --> 00:00:53,714
時間都花在你從像素上發出的成千上萬射線上

16
00:00:53,739 --> 00:00:58,847
這個場景用了 12 條 CPU 線程花了 16 小時繪製，結果還是有點雜訊

17
00:00:58,873 --> 00:01:03,235
還有其他演算法像是 Photon Mapping 跟雙向路徑追蹤（Bidirectional Path Tracing）

18
00:01:03,259 --> 00:01:05,026
試圖兼顧效率跟成果

19
00:01:05,051 --> 00:01:10,279
大致上的概念是從發射體打出光射線，在射線觸摸到的位置上儲存光的輻射率

20
00:01:10,304 --> 00:01:14,104
然後再從攝影機位置光線追蹤，把先前儲存的光蒐集回來

21
00:01:14,129 --> 00:01:18,122
有足夠的時間，路徑追蹤能產生其他方法難以企及的真實感

22
00:01:18,147 --> 00:01:22,333
設置正確，繪圖過程就是真的在模擬光在場景的行進

23
00:01:22,358 --> 00:01:24,414
而非參入藝術性的近似

24
00:01:24,439 --> 00:01:28,421
我在 80 90 年代曾經參與全域照明系統的製作

25
00:01:28,446 --> 00:01:33,124
即使是那時，我們便已知道有夠多的運算力，路經追蹤能給出正確結果

26
00:01:33,149 --> 00:01:36,052
流行的玩笑話是我們只要等

27
00:01:36,077 --> 00:01:44,241
去替其他演算法最佳化，然後等 50 年到電腦夠強每像素可以打一萬條射線，就有正確答案

28
00:01:44,266 --> 00:01:48,205
現在我覺得你大概一個像素要十萬或是百萬條

29
00:01:48,230 --> 00:01:52,350
根據我的計時，大概再等四分之一世紀就完成繪圖了

30
00:01:52,375 --> 00:01:56,230
然後技術奇點就會到來，前提是沒有人往場景放更多東西

