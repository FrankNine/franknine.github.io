1
00:00:00,001 --> 00:00:04,817
我在投影後跟除以 W 之間跳過了一步「裁切」

2
00:00:04,842 --> 00:00:08,170
假設有兩個點，一個是 (0, 4, -6)

3
00:00:08,195 --> 00:00:12,729
透視座標變換後變成 (0, 4, 5, 6)

4
00:00:12,754 --> 00:00:16,069
然後 (0, 6, -4) 變成這個值

5
00:00:16,093 --> 00:00:17,767
它們連成一個線段

6
00:00:17,792 --> 00:00:21,915
這兩點跟線段顯示在這個視錐放大圖上

7
00:00:21,940 --> 00:00:24,421
第二個點在視錐外

8
00:00:24,446 --> 00:00:29,861
我們希望所有座標都落在視野容體跟 NDC 的範圍內，這樣才能繪製

9
00:00:29,886 --> 00:00:34,208
裁切作用在超出視錐的線段或是三角形的邊

10
00:00:34,233 --> 00:00:37,236
一個邊可能被多個視錐的面裁切

11
00:00:37,261 --> 00:00:41,778
發生的事情是所有座標值被線性內插

12
00:00:41,778 --> 00:00:46,007
在這個例子視錐面上的位置在兩點正中間

13
00:00:46,032 --> 00:00:50,287
內插結果點是 (0, 5, 3.8, 5)

14
00:00:50,312 --> 00:00:54,749
然後照常除以 W 以取得 Normalized Device Coordinates 中的點

15
00:00:54,773 --> 00:00:57,102
接下來是裁切的概觀

16
00:00:57,127 --> 00:01:00,054
有個三角形超出視錐

17
00:01:00,079 --> 00:01:04,726
假設視錐左面先裁切三角形，這樣產生兩個新三角形

18
00:01:04,751 --> 00:01:08,378
接著視錐頂面裁切掉三角形另一部分

19
00:01:08,403 --> 00:01:13,183
總共製造出三個三角形，之後會各自被 GPU 柵格化

20
00:01:13,208 --> 00:01:18,378
你做為使用者不太需要關心裁切流程，都是自動幫你完成

21
00:01:18,403 --> 00:01:22,918
如果你想在 CPU 上做類似的測試的話可以熟悉一下

22
00:01:22,943 --> 00:01:28,663
在電腦圖學我們會強調我們將 3D 點跟向量存成齊次座標

23
00:01:28,688 --> 00:01:30,529
加上第四個元素 W

24
00:01:30,554 --> 00:01:36,631
實際上絕大部分的運算中 W 是 0，即向量，或是 1，即點

25
00:01:36,656 --> 00:01:41,161
只有在投影後裁切中 W 才會出現 1 以外的值

26
00:01:41,186 --> 00:01:45,786
當裁切結束，進入 Normalized Device Coordinates 我們就不需要齊次座標了

27
00:01:45,811 --> 00:01:50,538
但 Vertex Shader 必須產出齊次座標

28
00:01:50,563 --> 00:01:57,485
在座標被投影矩陣變換但還沒有除 W 之前，這個座標叫裁切座標（Clip Coordinate）

29
00:01:57,510 --> 00:02:03,733
Vertex Shader 能產生其他中間值，像是施加了模型視角矩陣的位置

30
00:02:03,758 --> 00:02:08,241
Vertex Shader 必須要產生螢幕上的位置

31
00:02:08,265 --> 00:02:10,655
這位置是齊次座標

32
00:02:10,680 --> 00:02:14,936
然後柵格單元拿這個座標進行裁切

