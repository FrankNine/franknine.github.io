1
00:00:00,007 --> 00:00:03,629
現在我們在像素層級，來談談反鋸齒（Antialiasing）

2
00:00:03,654 --> 00:00:08,394
我們預設柵格化場景時，我們看的是像素的中心

3
00:00:08,419 --> 00:00:10,539
這樣可能結果會很糟

4
00:00:10,564 --> 00:00:15,661
三角形邊緣的像素會只有完全被遮蓋跟完全沒被遮蓋兩種狀態

5
00:00:15,686 --> 00:00:20,558
這過程的二元性產生的效果稱為 Aliasing，造成鋸齒狀的邊緣

6
00:00:20,583 --> 00:00:23,799
非正式的稱呼有 Jaggies 或 Stairstepping

7
00:00:23,824 --> 00:00:26,658
在動畫中看到則稱為 Crawlies

8
00:00:26,682 --> 00:00:28,855
我們想要的是平滑的結果

9
00:00:28,880 --> 00:00:34,537
邊緣上的像素是照被各個重疊物件遮蓋的比例上色

10
00:00:34,562 --> 00:00:39,697
如果像素被這個三角形遮蓋較多就多用它的顏色，反之亦然

11
00:00:39,722 --> 00:00:42,142
難處在算出這個遮蓋率

12
00:00:42,167 --> 00:00:46,053
要計算、儲存、混色每個像素上所有三角形資訊非常昂貴

13
00:00:46,078 --> 00:00:50,133
也許到有個人飛行背包那時就可能了

14
00:00:50,158 --> 00:00:55,533
互動式 3D 圖學有許多反鋸齒作法嘗試

15
00:00:55,558 --> 00:00:57,924
光譜的一端是 Super-sampling

16
00:00:57,949 --> 00:01:03,070
單純就是創造更高解析度的影像，然後用這些取樣產生最終影像

17
00:01:03,095 --> 00:01:08,981
假設你要 1000 X 1000 像素的影像，你可能以 4000 X 4000 來繪製

18
00:01:09,006 --> 00:01:13,452
現在一個像素在高解析度影像有 16 個關聯的像素

19
00:01:13,477 --> 00:01:16,124
將這些混色，你就會得到更好的結果

20
00:01:16,149 --> 00:01:20,061
因為一些原因，這個做法被認為是糟的

21
00:01:20,086 --> 00:01:23,563
首先是記憶體與計算成本太高

22
00:01:23,588 --> 00:01:30,643
另外是在 4 X 4 個網格取樣對於接近垂直或是水平的線效果不好

23
00:01:30,668 --> 00:01:36,265
有種 GPU 通常會支援的作法是 Multi-sampling 反鋸齒，即 MSAA

24
00:01:36,290 --> 00:01:39,423
想法是計算 Fragment 顏色一次

25
00:01:39,448 --> 00:01:42,072
在另外計算幾何的遮蓋比例

26
00:01:42,097 --> 00:01:44,936
此外取樣方式不是格狀的

27
00:01:44,961 --> 00:01:48,200
這對水平跟垂直線有很大的幫助

28
00:01:48,225 --> 00:01:52,571
取樣模式取決於製造 GPU 的公司

29
00:01:52,596 --> 00:01:55,057
有處理與儲存的成本

30
00:01:55,082 --> 00:02:00,473
但這些成本比暴力 Super-sampling 低得多

31
00:02:00,506 --> 00:02:04,278
這是 WebGL 大部分預設的反鋸齒方式

32
00:02:04,303 --> 00:02:08,362
我說大部分因為反鋸齒只能開關

33
00:02:08,387 --> 00:02:11,893
沒有指明是哪種反鋸齒

34
00:02:11,918 --> 00:02:17,602
在 Three.js 設定反鋸齒，將 antialias 參數設為 true

35
00:02:17,627 --> 00:02:20,835
打開這個不一定有效果

36
00:02:20,860 --> 00:02:24,528
還取決於 GPU 是否支援反鋸齒，通常是有

37
00:02:24,552 --> 00:02:26,908
還有瀏覽器是否允許

38
00:02:26,933 --> 00:02:30,217
有時會希望把反鋸齒關閉以迴避 bug

39
00:02:30,242 --> 00:02:36,624
可惜我們在課程裡展示的 Three.js 都因為這個 bug 沒有開反鋸齒

40
00:02:36,649 --> 00:02:40,114
歡迎來到「尖」端科技

41
00:02:40,139 --> 00:02:43,987
另一類反鋸齒演算法是在影像上過濾

42
00:02:44,012 --> 00:02:46,480
這是較新的技術

43
00:02:46,505 --> 00:02:50,459
第一種叫 Morphological 反鋸齒，或是 MLAA

44
00:02:50,483 --> 00:02:52,705
在 2009 年開發出來的

45
00:02:52,730 --> 00:02:57,447
想法是偵測影像或是其它資料上出現的尖銳邊緣

46
00:02:57,472 --> 00:03:01,675
遇到這種邊就用鄰近的像素模糊這種邊

47
00:03:01,700 --> 00:03:04,186
這些技術效果不錯

48
00:03:04,211 --> 00:03:07,744
雖然處理細線、文字與其他特殊情況會失敗

49
00:03:07,769 --> 00:03:11,013
一種流行的作法叫 FXAA

50
00:03:11,037 --> 00:03:13,124
只需要影像本身就能運作

51
00:03:13,149 --> 00:03:16,638
我自己用在產品上過，Three.js 也有

52
00:03:16,663 --> 00:03:20,055
我想一部分的流行來自作者 Timothy Lates

53
00:03:20,080 --> 00:03:25,546
花功夫讓這個 Shader 跑在任何 GPU 上

54
00:03:25,571 --> 00:03:27,974
還有寫了詳盡的文件

55
00:03:27,999 --> 00:03:31,633
如果你沒聽清楚，再說一次，寫程式記得註解

56
00:03:31,658 --> 00:03:34,075
尤其是你想給別人看

57
00:03:34,099 --> 00:03:37,213
在 WebGL 跟 Three.js 大家都看得到

58
00:03:37,238 --> 00:03:40,049
所以我再說一次，寫程式記得註解

