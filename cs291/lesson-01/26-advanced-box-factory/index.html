<main>
  <div class="post-content">
    <p><iframe id="video" width="100%" height="400" src="https://www.youtube.com/embed/vjr-HsxiYvw?yt:cc=on" frameborder="0" allowfullscreen="true"></iframe>
<script src="/js/youtube.external.subtitle.min.js"></script>
<script src="/js/subtitles.parser.min.js"></script>
<script>
  var loadSRT = function(url, callback) {
    var httpRequest = new XMLHttpRequest();

    httpRequest.onreadystatechange = function() {
      if (httpRequest.readyState === XMLHttpRequest.DONE) {
        var subtitles = parser.fromSrt(httpRequest.responseText, true);

        for (var i in subtitles) {
          subtitles[i] = {
            start : subtitles[i].startTime / 1000,
            end   : subtitles[i].endTime / 1000,
            text  : subtitles[i].text
          };
        }

        callback(subtitles);
      }
    };

    httpRequest.open('GET', url, true);
    httpRequest.send(null);
  };

  loadSRT('/cs291/srt/Lesson 01\/26 Advanced Box Factory - Interactive 3D Graphics-vjr-HsxiYvw.srt', function(subtitles) {
    var youtubeExternalSubtitle = new YoutubeExternalSubtitle.Subtitle(document.getElementById('video'), subtitles);
  });
</script>
This question needs a rewording: instead of &ldquo;At what rate&hellip;&quot;, please change that to &ldquo;Once the pipeline is full, how often do boxes come off this pipeline?&rdquo; My apologies for the confusion. Also, note that it's a true pipeline. One cutter does his cuts and then passes it on to the next cutter, once every five seconds. That next cutter cuts and passes it to the folder in the next five seconds, <em>while at the same time</em> the first cutter is now doing cuts on a new box.</p>
<p>I should note that what I’m describing is a typical desktop or laptop computer’s GPU. Portable devices such as smart phones and tablets will usually use tile-based rendering instead. There’s a brief explanation of this algorithm <a href="http://www.onepc.net/reviews/0026/page2.shtml">here</a>. The good news is that even this type of architecture can still be controlled by WebGL.</p>

  </div>
</main>