<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Unity 和 git - Northern Wind</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Chun-Fu Chao" /><meta name="description" content="用 git 管理 Unity 專案有好一陣子了，剛好最近公司的 Open-source Unity Builder mimiron-lite 發布新版。同時公開了新的作為公司內標準的 git 設定檔。想分享一些設定檔背後的思維還有 git 使用的經" />






<meta name="generator" content="Hugo 0.111.3 with theme even" />


<link rel="canonical" href="https://franknine.github.io/posts/unity-git/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.e1e2a0bc37cfb7c7c75cf44bf0dddb9731bfd371c71d7c30dc1e5b6932f4ef5e.css" rel="stylesheet">

<link rel="stylesheet" href="/css/twitter_center.css">


<meta property="og:title" content="Unity 和 git" />
<meta property="og:description" content="用 git 管理 Unity 專案有好一陣子了，剛好最近公司的 Open-source Unity Builder mimiron-lite 發布新版。同時公開了新的作為公司內標準的 git 設定檔。想分享一些設定檔背後的思維還有 git 使用的經" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://franknine.github.io/posts/unity-git/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-10T23:20:12+08:00" />
<meta property="article:modified_time" content="2020-05-10T23:20:12+08:00" />
<meta itemprop="name" content="Unity 和 git">
<meta itemprop="description" content="用 git 管理 Unity 專案有好一陣子了，剛好最近公司的 Open-source Unity Builder mimiron-lite 發布新版。同時公開了新的作為公司內標準的 git 設定檔。想分享一些設定檔背後的思維還有 git 使用的經"><meta itemprop="datePublished" content="2020-05-10T23:20:12+08:00" />
<meta itemprop="dateModified" content="2020-05-10T23:20:12+08:00" />
<meta itemprop="wordCount" content="9351">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Unity 和 git"/>
<meta name="twitter:description" content="用 git 管理 Unity 專案有好一陣子了，剛好最近公司的 Open-source Unity Builder mimiron-lite 發布新版。同時公開了新的作為公司內標準的 git 設定檔。想分享一些設定檔背後的思維還有 git 使用的經"/>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-BP1PMVB7ZQ"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-BP1PMVB7ZQ', { 'anonymize_ip': false });
}
</script>



<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Northern Wind</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/cs291/">
        <li class="mobile-menu-item">CS291</li>
      </a><a href="https://github.com/FrankNine/franknine.github.io/wiki">
        <li class="mobile-menu-item">Wiki</li>
      </a><a href="/index.xml">
        <li class="mobile-menu-item">RSS</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Northern Wind</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/cs291/">CS291</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://github.com/FrankNine/franknine.github.io/wiki">Wiki</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/index.xml">RSS</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <div class="post-content">
    <p>用 git 管理 Unity 專案有好一陣子了，剛好最近公司的 Open-source Unity Builder <a href="https://gitlab.com/rayark/mimiron-lite">mimiron-lite</a> 發布新版。同時公開了新的作為公司內標準的 git 設定檔。想分享一些設定檔背後的思維還有 git 使用的經驗。</p>
<p>TL;DR 的話可以直接參考已經編輯好的 git 設定檔，現在最新的設定包含 Wwise 的 <code>.gitignore</code> 已經獨立更新到： <a href="https://github.com/FrankNine/RepoConfig">https://github.com/FrankNine/RepoConfig</a><br>
這個 Repo Fork 自： <a href="https://github.com/rayark/repo-config">https://github.com/rayark/repo-config</a><br>
公司將這個設定以 <a href="https://tldrlegal.com/license/mit-license">MIT 授權</a> 釋出。</p>
<p>如果對 git 操作不熟悉的話，目前中文教學最推薦的還是 <a href="https://gitbook.tw/">為你自己學 Git</a> by <a href="https://twitter.com/eddiekao">高見龍</a>。除了線上版教的基本操作外，付費版內很難得有 git 資料結構（Commit、Tree、Blob）的介紹，對於更加熟悉 git 非常有幫助。</p>
<h1 id="用戶端">用戶端</h1>
<p>之前為了公司需要同時滿足技術人員與非技術背景人員操作 git 的需求 Survey 了很多 git 用戶端，目前選定的是需要付費的 <a href="https://git-fork.com/">Fork</a>。在這之前用的是最常見免費的 <a href="https://www.sourcetreeapp.com/">SourceTree</a>，不過登入上常常會出現 <a href="https://community.atlassian.com/t5/Sourcetree-questions/Git-Credential-Manager-for-Windows-Popups/qaq-p/579905">問題</a> 需要排解，還有有的時候檔案多的時候會變很慢，對圖片與 LFS 檔案也沒有預覽支援。另外有些程式同事會選用 Git for Windows 附帶的 <a href="http://gitextensions.github.io/">Git Extensions</a> 但是這個對美術使用上有些不友善，習慣用戶端有一個視窗的也可能會不習慣 Shell Extension。另一個免費的 Shell Extension 選擇是 <a href="https://tortoisegit.org/">TortoiseGit</a>，對美術素材支援到顯示 LFS 內的圖片，但是在 Blame、Rebase 之類比較複雜的操作比較不順手。<a href="https://desktop.github.com/">GitHub Desktop</a> 是功能太陽春，<a href="https://www.gitkraken.com/">GitKraken</a> 雖然有做很多美術相關的功能但是可能是因為 Electron 先天問題，在大 Repo 上還蠻喘的。<a href="https://www.syntevo.com/smartgit/">SmartGit</a> 則是功能雖多但是對美術素材支援算是沒有，而且年費不便宜。</p>
<figure class="center"><img src="/images/unity-git/fork.png"/><figcaption>
            <h4>Fork</h4>
        </figcaption>
</figure>

<p>目前 Fork 提供 Windows 跟 Mac 的原生用戶端，平常速度上算是不錯。付費目前是一次性 <a href="https://git-fork.com/buy">50 USD</a> 一個序號最多啟動三台電腦，也比需要訂閱的工具負擔低（雖然不知道以後會不會改）。介面上相當簡潔但可以滿足大部分的開發需求，內建的 Rebase 跟 Merge 介面難得做得算好用。對於遊戲開發算是 Killer Feature 是內建的圖片預覽跟 diff（diff Mac 版還只有 Side-by-side 沒有 Swipe 跟 Onion Skin），而且在 LFS 的配置下也能正常運作。</p>
<figure class="center"><img src="/images/unity-git/swipe-image-diff.gif" width="400"/><figcaption>
            <h4>https://git-fork.com/blog/posts/forkwin-1.38/</h4>
        </figcaption>
</figure>

<h1 id="伺服器端">伺服器端</h1>
<p>一般的 git Hosting 服務在 LFS 的容量與流量限制較多（<a href="https://help.github.com/en/github/setting-up-and-managing-billing-and-payments-on-github/about-billing-for-git-large-file-storage">GitHub 的 LFS 條款</a>），對遊戲專案比較不友善。Riot 的《符文大地傳說》在 <a href="https://technology.riotgames.com/news/legends-runeterra-cicd-pipeline">分享文章</a> 中提到他們是使用 GitHub Enterprise，搭配使用 <a href="https://jfrog.com/artifactory/">Artifactory</a> 作為 LFS Server。使用 Hosting 服務代表 git 操作要走公司聯外網路，在素材大一些的專案以台灣網路狀態也不太實際。如果情況許可推薦用主機或是 NAS 架設 <a href="https://about.gitlab.com/install/">GitLab</a>。GitLab 可以滿足 git、<a href="https://docs.gitlab.com/ee/ci/introduction/">CI Runner</a>、<a href="https://about.gitlab.com/solutions/project-management/">專案管理</a> 與 <a href="https://docs.gitlab.com/ee/user/project/merge_requests/creating_merge_requests.html">Code Review</a> 等功能，雖然可能專案管理介面沒有像 Trello 或其他工具漂亮、順手。但是這幾個功能在 GitLab 裡可以相互 Reference，像是在 Issue 上面 Reference Merge Request 的進度或是特定 CI Pipeline 的建置結果，這種整合是難以取代的。只是走 Self-hosting IT 方面工就會比較多，備份方面也要注意。</p>
<figure class="center"><img src="/images/unity-git/group-issue-board.png" width="700"/><figcaption>
            <h4>https://about.gitlab.com/stages-devops-lifecycle/issueboard/</h4>
        </figcaption>
</figure>

<h1 id="external-merger">External Merger</h1>
<p>合併工具大家一般可能用內建的 <a href="http://kdiff3.sourceforge.net/">KDiff3</a>，不過我自己從以前第一份工作用 Perforce 的經驗就非常喜歡 Perforce 的合併工具。幸好 Perforce 的合併工具 <a href="https://www.perforce.com/products/helix-core-apps/merge-diff-tool-p4merge">P4Merge</a> 可以單獨安裝使用且不收費。大部分的 git 用戶端都可以設定要用哪個外部合併工具，也大多可以識別 P4Merge。程式合併挑選改動跟編輯合併結果相當好用，diff 的判讀也比其他工具好。再加上有非常強大的圖片 diff，可以標出有差異的像素在哪裡。要說明顯的缺點就是非英文字符不太支援，會有亂碼跟 UI 錯亂現象。</p>
<figure class="center"><img src="/images/unity-git/p4merge-pixel-diff.png"/><figcaption>
            <h4>P4Merge image diff</h4>
        </figcaption>
</figure>

<figure class="center"><img src="/images/unity-git/p4merge-three-way-merge.gif" width="500"/><figcaption>
            <h4>P4Merge three way merge</h4>
        </figcaption>
</figure>

<h1 id="設定">設定</h1>
<h2 id="unity">Unity</h2>
<p>要進行版本控制 Unity 內的 AssetSerialization 要設定成 <a href="https://docs.unity3d.com/Manual/class-EditorManager.html">Force Text 和 Visible Meta Files</a> 算是基本，Force Text Unity 資源才會存成可以 diff 的 YAML，Visible Meta Files 才能跟其他機器上工作的人同步 GUID。只有在很久以前 Unity 4.X 的時代因為編輯器是 32 位元不能定址超過 4G 的記憶體而 Force Text 會增加記憶體用量會考慮關掉。現在的 Unity 編輯器都是 64 位元不會有這個問題，Force Text 和 Visible Meta Files 後來也變成是預設選項。</p>
<h2 id="gitconfig">.gitconfig</h2>
<h3 id="coreignorecase">core.ignorecase</h3>
<p>最重要會要求團隊所有成員設定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git config --global core.ignorecase true
</span></span></code></pre></td></tr></table>
</div>
</div><p>讓 git 把大小寫不同的檔案視為同一檔案。因為 Mac、Linux 等系統上有可能是 Case-sensitive 檔案系統，大小寫不同的檔案視為不同檔案，但是在 Windows 上卻視為相同檔案。如果沒有這樣設定則 Mac 的使用者可以推名稱只有大小寫不同的檔案進到 Repo，然後用 Windows 的成員會拉不下來，或是遇到檔案變動 Revert 後馬上恢復成 Modified 的狀態。如果有任何非得做檔名大小寫改變的動作，請使用 <a href="https://git-scm.com/docs/git-mv"><code>git mv</code></a> 不要自己刪除檔案 Commit 再改名 Commit，檔案歷史的認定上可能會錯亂。</p>
<p>參考資料：</p>
<ul>
<li><a href="https://gitbook.tw/posts/2018-06-05-case-sensitive">關於檔名的大小寫</a></li>
</ul>
<p>因為我們設定了 <code>core.ignorecase true</code>，所以在設定 <a href="https://github.com/FrankNine/RepoConfig/blob/master/.gitignore"><code>.gitignore</code></a> 與 <a href="https://github.com/FrankNine/RepoConfig/blob/master/.gitattributes"><code>.gitattributes</code></a> 也就不會特別加入 Match 大小寫的 Pattern。</p>
<h3 id="corefsmonitor--featuremanyfiles">core.fsmonitor / feature.manyFiles</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git config --global core.fsmonitor true
</span></span><span class="line"><span class="cl">git config --global feature.manyFiles true
</span></span></code></pre></td></tr></table>
</div>
</div><p>以遊戲專案的大小，任何有助於 git 操作速度的設定都該使用。<a href="https://git-scm.com/docs/git-update-index#_file_system_monitor">File System Monitor</a> 可以利用作業系統功能加速檔案修改的偵測，<a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-featuremanyFiles">Many Files</a> 則可以加速 Untracked 檔案的偵測。</p>
<p>參考資料：</p>
<ul>
<li><a href="https://canvatechblog.com/we-put-half-a-million-files-in-one-git-repository-heres-what-we-learned-ec734a764181">We Put Half a Million files in One git Repository, Here’s What We Learned</a></li>
</ul>
<h2 id="gitignore">.gitignore</h2>
<p><code>.gitignore</code> 主要是忽略「應該留在電腦上，但是不應該共用出去的檔案」除了 Unity 的 <code>Temp</code> 與 <code>Library</code> 之外，主要是程式編輯器的設定。使用過後不應該保留的檔案，像是 Unity 產生的 Xcode 專案目錄或是 APK 我是習慣不加 <code>.gitignore</code>，讓它們被認定為是 Untracked File 方便本地或是 CI Runner 上以 <a href="https://git-scm.com/docs/git-clean"><code>git clean</code></a> 清除。一個小細節是如果 Pattern 以 <code>/</code> 開頭只會 Match Repo 根目錄下的檔案或目錄，像是 Unity 的 Library 我會寫成 <code>/Library/</code> 以免忽略到其他目錄裡面叫做 Library 的目錄。設定的範例可以參考：</p>
<p><a href="https://github.com/FrankNine/RepoConfig/blob/master/.gitignore">https://github.com/FrankNine/RepoConfig/blob/master/.gitignore</a></p>
<h2 id="gitattributes">.gitattributes</h2>
<p><code>.gitattributes</code> 因為牽涉到 <a href="https://git-lfs.github.com/">LFS</a> 跟 <a href="https://help.github.com/en/github/using-git/configuring-git-to-handle-line-endings">CRLF</a> 所以就比較複雜了。</p>
<h3 id="lfs-large-file-storage">LFS (Large File Storage)</h3>
<p>先說 LFS，基本上是把特定副檔名的檔案搬出 git 移動到 LFS Server，而原來的 git 路徑只留下 <a href="https://github.com/git-lfs/git-lfs/blob/master/docs/spec.md#the-pointer">Pointer File</a>，Pointer File 裡有 oid。當有需要時 LFS 會用 Pointer File 裡的 oid 到 LFS Server 查找、下載檔案並取代（<a href="https://git-scm.com/book/zh-tw/v2/Customizing-Git-Git-Attributes#rfilters_a">Smudge</a>）掉 Pointer File。</p>
<p>Pointer File 的內容範例如下，容量大約 130 bytes 左右。記得這個容量大小，如果看到檔案變成這個大小要想是不是 LFS 的替換沒有正常執行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">version https://git-lfs.github.com/spec/v1
</span></span><span class="line"><span class="cl">oid sha256:4d7a214614ab2935c943f9e0ff69d22eadbb8f32b1258daaa5e2ca24d17e2393
</span></span><span class="line"><span class="cl">size 12345
</span></span><span class="line"><span class="cl">(ending \n)
</span></span></code></pre></td></tr></table>
</div>
</div><p>現在 git 用戶端通常都會偵測 LFS 並在 Clone 的時候做好 LFS 的設定，不過如果 LFS 替換有問題可以手動執行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git lfs install
</span></span><span class="line"><span class="cl">git lfs pull
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 LFS 可以降低 git 歷史的大小，因為 git 本身變成只儲存 Pointer File。這樣可以降低 Clone 在本機硬碟上的大小，並增進效率。降低 Clone 大小這件事對 Binary 檔案大的 3D 遊戲專案非常有感。但是缺點有：</p>
<ul>
<li>git 操作變成要持續跟 LFS Server 溝通，喪失 git 完全分散式與可離線工作的優點。</li>
<li>有時需要排除 LFS 製造的問題，最常見的是 Clone 或是 Fetch 的時候 LFS 沒有觸發替換 Pointer File 為真正的檔案內容。有些罕見有遇過的是 GitLab 的 LFS Server 弄丟檔案導致 Fetch 不下來。或是在開啟 LFS 又 Fork 的情況下，GitLab LFS Repo 可能需要 <a href="https://gitlab.com/gitlab-org/gitlab/-/issues/271576">重新同步</a>。目前建議使用 GitLab LFS 跟 Fork 功能不要同時使用。</li>
<li>有些功能可能在 LFS 環境下會不能使用，包含部分工具可能會無法 diff LFS 檔案，<a href="https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4040">gitlab-runner exec 在有 LFS 的環境下還無法使用</a>。</li>
</ul>
<p>以遊戲 Binary 檔案佔 Repo 大部分容量的情況下是建議遊戲專案使用 LFS 的，而且越早用越好，因為已經推進 git 歷史裡的 Binary 檔案會一直留在歷史裡，修改 <code>.gitattributes</code> 只會影響到後面增加的檔案。如果 Repo 已經大到受不了了，只能做 Migration 一途，但是變成所有人都要重新 Clone，是超大的工程。</p>
<p>要進行 Migration 首先要在本地 Track 所有的分支，因為 <code>lfs migrate</code> 只會作用在本地分支：<br>
<a href="https://stackoverflow.com/questions/379081/track-all-remote-git-branches-as-local-branches">https://stackoverflow.com/questions/379081/track-all-remote-git-branches-as-local-branches</a></p>
<p>然後執行（以改寫 <code>.png</code> 與 <code>.psd</code> 歷史成為 LFS 作示範）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git lfs migrate import --everything --include<span class="o">=</span><span class="s2">&#34;.png,.psd&#34;</span>
</span></span><span class="line"><span class="cl">git reflog expire --expire<span class="o">=</span>now --all <span class="o">&amp;&amp;</span> git gc --prune<span class="o">=</span>now
</span></span><span class="line"><span class="cl">git remote set-url origin &lt;新 repo 位置&gt;
</span></span><span class="line"><span class="cl">git push --all origin --force
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外一種常見的狀況是修改了 <code>.gitattributes</code> 把新的附檔名納入 LFS 範圍，但是已經存在的檔案沒有置換成 Pointer File，這時候在 Clone 或是 Reset 的時候都會收到警告：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Encountered 1 file(s) that should have been pointers, but weren&#39;t
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果沒有要往回整理歷史只是要把目前檔案換成 Pointer File，可以用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># from https://stackoverflow.com/a/51626808</span>
</span></span><span class="line"><span class="cl">git rm --cached -r .
</span></span><span class="line"><span class="cl">git reset --hard
</span></span></code></pre></td></tr></table>
</div>
</div><p>或是使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># from https://github.com/git-lfs/git-lfs/issues/3421#issuecomment-610489798</span>
</span></span><span class="line"><span class="cl">git add --renormalize .
</span></span></code></pre></td></tr></table>
</div>
</div><p>然後把檔案變動 Commit / Push 即可。</p>
<p>只要在 <code>.gitattributes</code> 加入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">*.png filter=lfs diff=lfs merge=lfs
</span></span></code></pre></td></tr></table>
</div>
</div><p>像這樣就可以把 PNG 圖檔交給 LFS 管理（因為有設定 <code>core.ignorecase true</code> 所以我們不用寫成 <code>*.[pP][nN][gG]</code>）。基本上所有不能直接文字編輯的二進位檔案都該加入 LFS，但是 Unity Prefab (<code>.prefab</code>) 跟 Scene (<code>.unity</code>) 我會選擇不加入 LFS。在 AssetSerialization 設定為 Force Text 後 Unity 的 GameObject 結構 YAML 算是可以判讀與做文字 diff 的，很多時候可以這樣確認 Prefab 或是 Scene 的修改有沒有意外改到別的東西。</p>
<p>YAML 判讀方面可以參考官方的文章來入門：<a href="https://blog.unity.com/technology/understanding-unitys-serialization-language-yaml">Understanding Unity’s serialization language, YAML</a></p>
<p>如果你也習慣這樣判讀 Scene 跟 Prefab 的改動，記得在升級 Unity 的時候要對所有 Scene 跟 Prefab 下 <a href="https://docs.unity3d.com/ScriptReference/AssetDatabase.ForceReserializeAssets.html">AssetDatabase.ForceReserializeAssets</a> 把 <code>.prefab</code> 或是 <code>.unity</code> 升級到新的 Unity 的格式。因為 Unity 預設行為會 Lazy 升級後要等到有改動才用新格式儲存（這是 Unity 編輯器的設計理念，Material 檔案儲存也有類似的 Lazy 行為），但這樣會變成你的改動跟升級的改動混在一起難以判讀 diff，所以需要在剛升級 Unity 還沒有修改的時候強制檔案升級。</p>
<p>Unity 有提供自己的 <a href="https://docs.unity3d.com/Manual/SmartMerge.html">YAML merger</a>，不過試用之後覺得結果偶而怪怪的。目前還是只有判讀 diff，沒有在對 Scene 跟 Prefab 使用自動合併。</p>
<p>另外一個特例是 <code>.dll</code>，當 DLL 沒有正確被替換時會造成編譯錯誤，如果 Unity 在抱怨找不到應該定義在 DLL 內的 Symbol 時記得先檢查專案內的 DLL 是不是只有 Pointer File 的 130 bytes 大小。</p>
<h3 id="crlf">CRLF</h3>
<p><code>.gitattributes</code> 另一個大坑是 <a href="https://blog.miniasp.com/post/2013/09/15/Git-for-Windows-Line-Ending-Conversion-Notes">CRLF</a>，因為 Windows (CRLF <code>\r\n</code>)、 Mac (OSX 以前 CR <code>\r</code>，以後 LF <code>\n</code>) 與 Linux (LF <code>\n</code>) 的行尾不同，git 預設會在 Checkout 與 Commit 時幫你做轉換，也就是 autocrlf。但是如果沒有小心設定會導致兩個問題：</p>
<ul>
<li>轉換到根本不是文字的 Binary 檔案，這樣檔案本地開起來會是壞的</li>
<li>有些檔案行尾不斷改變，最常見的是 <code>.meta</code>，造成很多不是人為編輯造成的改動</li>
</ul>
<p>很多人可能會用這個很熱門的 Unity <code>.gitattribute</code> 樣本：<br>
<a href="https://gist.github.com/nemotoo/b8a1c3a0f1225bb9231979f389fd4f3f">https://gist.github.com/nemotoo/b8a1c3a0f1225bb9231979f389fd4f3f</a></p>
<p>但是它將了 Unity 的 <code>.asset</code> 檔案設定為 LF，而 Unity 有非常多種 <code>.asset</code> 檔案，之前調查過的結果</p>
<ul>
<li>CRLF
<ul>
<li><code>ProjectSettings</code> 下的 <code>.asset</code></li>
</ul>
</li>
<li>LF
<ul>
<li><a href="https://docs.unity3d.com/Manual/class-Tilemap.html">Tilemap</a> 設定檔</li>
</ul>
</li>
<li>Force Text 設定下還是 Binary 內容
<ul>
<li><a href="https://docs.unity3d.com/Manual/LightmapSnapshot.html">Lighting Data</a></li>
<li><a href="https://docs.unity3d.com/Manual/terrain-UsingTerrains.html">Terrain Data</a></li>
</ul>
</li>
</ul>
<p>強制轉換成 LF 會產生問題，底下也有人回報，但是一直沒有更新，所以不建議用這份設定。</p>
<p>我自己最後的設定是開頭：</p>
<p><code>* -text</code></p>
<p>預設先將所有檔案的 <a href="https://git-scm.com/docs/gitattributes#_text">Text 屬性</a> 拔掉關閉行尾轉換，之後再利用 <code>.gitattributes</code> 可以用下方的規則覆寫上方的規則的特性用白名單方式加回純文字程式碼的行尾轉換。</p>
<p>沒有寫成</p>
<p><code>* binary</code></p>
<p>是因為 <a href="https://git-scm.com/docs/gitattributes#_using_macro_attributes">Binary</a> 代表 <code>-text -diff</code>，我們希望拔掉行尾轉換但是希望對 <code>.scene</code>、<code>.prefab</code> 與 <code>.meta</code> 留住文字 diff。看 diff 可以抓到 GameObject、Component 的變化，或是 <code>.meta</code> 的 GUID 跑掉的情況。</p>
<figure class="center"><img src="/images/unity-git/prefab-diff.png"/><figcaption>
            <h4>Prefab 在沒有加入 LFS 沒有 -diff 的情況下會在 git 用戶端裡顯示像這樣的 diff。可以看到我們把 RectTransform 大小改成 200 X 200，但同時不小心把 GameObject 關了。</h4>
        </figcaption>
</figure>

<figure class="center"><img src="/images/unity-git/meta-diff.png" width="600"/><figcaption>
            <h4>看到歷史裡面有像這樣 `.meta` 裡的 GUID 變化是非常危險的，代表 Reference 會掉。</h4>
        </figcaption>
</figure>

<p>至於行尾常常亂跳的 <code>.meta</code> 因為實驗出來在任何平台 Unity Editor 都是存成以 LF 換行，所以寫死</p>
<p><code>*.meta text eol=lf</code></p>
<p><code>.mat</code> 也應該是 LF 換行，不過它不常亂跳所以沒有像 <code>.meta</code> 寫死。</p>
<p>至於文字編輯的原始碼檔案則應該啟用 Text 與行尾設定壓過 <code>* -text</code> 設定，確保這些檔案在 repo 裡的行尾一致，以免像是 <code>git blame</code> 之類的工具受到整個原始碼的行尾跳動干擾難以閱讀。</p>
<p>以前是設定回 autocrlf，更新的版本我們統一使用 LF：</p>
<p><code>*.cs text eol=lf</code></p>
<p>因為我們試圖替 AssetBundle 計算自製的來源特徵 Hash，Hash 輸入除了 AssetBundle 的所有原始素材也包含所有程式原始碼檔案，因為程式可能有 <a href="https://docs.unity3d.com/ScriptReference/AssetImporter.html">AssetImporter</a> 會影響 Import 結果。為了讓 Hash 計算結果在 Windows 與 Mac 相同，現在統一使用 LF 行尾使原始碼檔案 Binary Representation 在上雙平台相同。Windows 上大部分的程式編輯器其實遇到 LF 結尾的原始碼還是能正常運作，影響不大。</p>
<p>P.S.<br>
（asmdef 改動會影響 Assembly 名稱會使 <a href="https://forum.unity.com/threads/asset-bundle-cannot-find-scripts-from-assembly-definition-files.531804/#post-3521699">AssetBundle 無法 Dereference 附著在 GameObject 上的 MonoBehaviour</a>，如果想靠自製特徵 Hash 來控制要不要更新 AssetBundle 也要追蹤 asmdef 變化）</p>
<p>想要使用普通的 Windows CRLF，Mac LF 可以對程式檔案套用這個設定：</p>
<p><code>*.cs text=auto</code></p>
<p>最後整套 <code>.gitattributes</code> 設定可以參考：
<a href="https://github.com/FrankNine/RepoConfig/blob/master/.gitattributes">https://github.com/FrankNine/RepoConfig/blob/master/.gitattributes</a></p>
<h2 id="editorconfig">EditorConfig</h2>
<p><a href="https://editorconfig.org/">https://editorconfig.org/</a></p>
<p>這個跟 git 本身無關，不過也是可以放在 Repo 裡的設定檔就順便提一下。目前我們使用的設定很陽春：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">root = true
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[*]
</span></span><span class="line"><span class="cl">charset = utf-8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">indent_style = space
</span></span><span class="line"><span class="cl">indent_size  = 4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">trim_trailing_whitespace = true
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>.gitattributes</code> 可以控制行尾，但是程式碼還可能會有文字編碼、BOM、或是 Tab / Space 不一致的問題。而編碼與 Tab / Space 可以靠在專案內放置 <code>.editorconfig</code> 提示程式編輯工具如何處理來完成。目前 Visual Studio、MonoDevelop 與 Rider 都會自動偵測 <code>.editorconfig</code> 的設定，而 Visual Studio Code 與 Notepad++ 則是需要安裝 Plugin。</p>
<p>更進一步可以把 Visual Studio 或是 ReSharper 的設定也放進 Repo，從使用工具讓行尾、Tab / Space 之類的統一提升到 Naming 或是 Coding Convention 的統一。不過因為公司還沒有統一導入 JetBrains 的編輯器，所以沒有這方面的實務經驗。</p>
<h1 id="worktree">Worktree</h1>
<p>如果是開發多平台遊戲的人可能會習慣 clone 同一個專案一次以上，然後把平台設定成不同，例如一個 Clone 平台設定成 Android 一個平台設定成 iOS。雖然 <a href="https://docs.unity3d.com/Manual/CacheServer.html">Cache Server</a> / <a href="https://docs.unity3d.com/Manual/UnityAccelerator.html">Accelerator</a> 或是 <a href="https://forum.unity.com/threads/what-is-asset-database-v2.680170/">AssetDatabase V2</a> 可以降低平台切換的成本，但是在硬碟上保留兩份專案還是最快最直觀的。缺點很直接是硬碟用量很大，其實可以 Clone 一次然後開一個以上的 <a href="https://git-scm.com/docs/git-worktree">Worktree</a>，這樣雖然還是有多個專案目錄，但是只會有一個 <code>.git</code> 資料夾，即電腦上只有一份 git 歷史。如果有容量的疑慮又電腦裝有容量大的傳統硬碟跟有限的 SSD，可以考慮把 git 歷史放在傳統硬碟，專案 Worktree 放在 SSD 上的安排。</p>
<p>在 git 根目錄輸入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git worktree add ../project-ios
</span></span></code></pre></td></tr></table>
</div>
</div><p>即在上層目錄再開一個叫 <code>project-ios</code> 的 Worktree</p>
<p>額外的 Worktree 一般的 git 用戶端都可以識別，操作起來跟操作普通的 Clone 沒有太大差別。</p>
<p>列舉 Worktree</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git worktree list
</span></span></code></pre></td></tr></table>
</div>
</div><p>當不需要使用時只要把 Worktree 刪除然後執行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git worktree prune
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以參考：</p>
<ul>
<li><a href="https://ihower.tw/blog/archives/8740">Git worktree: 同時開多個工作目錄</a> by ihower</li>
</ul>
<h1 id="hooks">Hooks</h1>
<p>git 可以在設定裡加入自動觸發的 Shell Script 來作檢查或清理，常見的需求有清除空目錄與其 <code>.meta</code> 跟檢查檔案 Commit 時有沒有加入對應的 <code>.meta</code>。不過這個我沒有推廣到整個團隊的經驗所以就沒有什麼個人經驗分享，可以參考：</p>
<ul>
<li><a href="https://networm.me/2016/06/26/unity-git-hooks/">Unity Git 钩子</a> by 狂飙 (清理空目錄)</li>
<li><a href="https://github.com/doitian/unity-git-hooks">doitian/unity-git-hooks</a> (清理空目錄與檢查 .meta)</li>
<li><a href="https://pre-commit.com/">pre-commit</a></li>
</ul>
<p>如果有機會自己做的話會比較想用 Python 之類的語言實現，這樣邏輯會比較好懂。另外空目錄的 <code>.meta</code> 平常不會造成問題，因此我沒有特別急著要用 Hook 檢查（Commit 內缺少 <code>.meta</code> 則是宣導後蠻少發生的，不過當然如果有自動檢查總是好）。但是有個特別要注意的是 iOS 與 Mac 環境的 <code>.framework</code> 與 <code>.bundle</code> 資料夾，這些資料夾裡面裝的是 Plugin 而 Import Settings 放在目錄 <code>.meta</code> 裡，如果刪除時沒有正確清理目錄 <code>.meta</code> 則 Xcode 會試圖 Import 空的 Plugin 然後建置失敗。</p>
<h1 id="rebase">Rebase</h1>
<p>使用 git 到現在算是適應 Fork 後 Fetch Upstream、Push Origin、開 Merge Request 的流程（可以參考 <a href="https://gitbook.tw/chapters/github/syncing-a-fork.html">【狀況題】怎麼跟上當初 fork 專案的進度？</a>），甚至是加其他同事的 fork 當作 Remote。在我自己的 fork 上面還蠻習慣用 <a href="https://git-scm.com/docs/git-rebase">Rebase</a> （<a href="https://gitbook.tw/chapters/branch/merge-with-rebase.html">另一種合併方式（使用 rebase）</a>）或是 <a href="https://git-scm.com/docs/git-cherry-pick">Cherrypick</a> （<a href="https://gitbook.tw/chapters/faq/cherry-pick.html">【狀況題】如果你只想要某個分支的某幾個 Commit？</a>）改造歷史的，如果有人在我合併之前早一步合併到主要分支，我會把自己分支 Rebase 到別人的 Merge 後重開 Merge Request，然後開 <code>--no-ff</code> （<a href="https://git-scm.com/docs/git-merge#Documentation/git-merge.txt---no-ff">no fast-forward</a>）弄出一串小耳多形狀的歷史（<a href="https://gitbook.tw/chapters/branch/merge-commit.html">[狀況題]為什麼我的分支都沒有「小耳朵」？</a>），方便以後回頭查找。另外有一種情況是可能某個 Feature 把 X 改成 Y，後來發現做錯了又從 Y 改成 Z。這樣的情況我會試著在發 Merge Request 之前把歷史改成 X -&gt; Z 而非 X -&gt; Y -&gt; Z 減少 Reviewer 的負擔。感覺這些操作可能可以加入 Code Review 標準，不過目前時程壓力狀況下還是只有我自己會要求自己，還沒有推廣的經驗。</p>
<figure class="center"><img src="/images/unity-git/merge-rebase.png"/><figcaption>
            <h4>Branch 直接使用 Merge 與 Rebase 後 merge --no-ff 的歷史差別，右邊 Rebase 的歷史比較好懂（歷史僅供示範用，工作的時候應該情況會更複雜）</h4>
        </figcaption>
</figure>

<p>關於 Rebase 有很多很好的中文文章，可以參考：</p>
<ul>
<li><a href="https://ihower.tw/blog/archives/3843">使用 git rebase 避免無謂的 merge</a> by ihower</li>
<li><a href="https://ihower.tw/git/rebase.html">還沒 push 前可以做的事</a> by ihower</li>
<li><a href="https://blog.yorkxin.org/2011/07/29/git-rebase.html">Git-rebase 小筆記</a> by yorkxin</li>
<li><a href="https://www.bitsnbites.eu/a-tidy-linear-git-history/">A tidy, linear Git history</a></li>
</ul>
<p>對非技術人員的話操作 Rebase 可能會比較困難，但是如果非程式都用 Pull 的話會產生大量的 Merge Commit。有一派的作法是替非技術人員設定 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-pullrebase">pull.rebase</a> 和 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-rebaseautoStash">rebase.autoStash</a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git config pull.rebase true
</span></span><span class="line"><span class="cl">git config rebase.autoStash true
</span></span></code></pre></td></tr></table>
</div>
</div><p>這樣在 Pull 的時候會觸發 Stash、Rebase 和 Apply Stash，對於減少 Merge Commit 蠻有效的。但是麻煩的是如果有衝突會從 Merge Conflict 變成更難排除的 Rebase Conflict。公司有些專案是要求這樣運作的，這可能要看各團隊非技術人員的接受度。</p>
<p>如果對 Pull Rebase 有興趣可以參考：</p>
<ul>
<li><a href="https://networm.me/2018/07/29/git-for-unity-project/#%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5">使用 Git 管理 Unity 项目</a> by 狂飙</li>
</ul>
<p>往前 Rebase 同時有接受主要分支的改動的功能，另一種做法是主要分支往 Feature Branch 做 Merge。但這樣 Merge 要交代所有成員小心發生衝突時的 Resolve，如果更新時的 Merge Resolve 做錯，在 Feature Branch 結束反著合向主要分支時是不會有任何警告，因為前面已經 Marked as Resolved 了。非技術人員偶爾會做錯，但是發生就會污染主要分支造成嚴重後果。如果不用 Rebase 要特別小心這點。</p>
<h1 id="sparse-checkout--shallow-clone">Sparse checkout &amp; Shallow clone</h1>
<p>在 Checkout 的時候其實不一定要 Checkout 出整個專案，可以將路徑 Pattern 寫入 <code>.git/info/sparse-checkout</code> 只 Checkout 特定的檔案或資料夾。以下是只 Clone 之後只 Checkout <code>/Assets/</code> 和 <code>/ProjectSettings/</code> 的示範。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git clone --no-checkout &lt;Repo URI&gt;
</span></span><span class="line"><span class="cl">cd &lt;Repo 路徑&gt;
</span></span><span class="line"><span class="cl">git config core.sparseCheckout true
</span></span><span class="line"><span class="cl">(echo /Assets/) &gt; .git/info/sparse-checkout
</span></span><span class="line"><span class="cl">(echo /ProjectSettings/) &gt;&gt; .git/info/sparse-checkout # &gt;&gt; 是 Append
</span></span><span class="line"><span class="cl">git checkout
</span></span></code></pre></td></tr></table>
</div>
</div><p>（<a href="https://github.blog/2020-01-13-highlights-from-git-2-25/">Git 2.25.0</a> 加入了 <a href="https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/"><code>git sparse-checkout</code></a>，可以用 <code>git sparse-checkout init</code> 取代 <code>git config core.sparseCheckout true</code> <a href="https://git-scm.com/docs/git-sparse-checkout#Documentation/git-sparse-checkout.txt-emsetem"><code>git sparse-checkout set/add</code></a> 取代直接編輯 <code>.git/info/sparse-checkout</code> ）</p>
<p>另外 <code>git clone</code> 可以加入 <a href="https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---depthltdepthgt"><code>--depth</code></a> 參數限制 Clone 下來的歷史深度</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git clone --depth 5 -b &lt;Branch&gt; &lt;Repo URI&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果要還原的話執行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git fetch --unshallow
</span></span></code></pre></td></tr></table>
</div>
</div><p>Sparse Checkout 與 Shallow Clone 都可以加快 git 操作的速度與減少空間用量，不過平常直接用在要編輯的 Clone 機會不多。最實用的應用是在設定 Build Pipeline 的 git，控制 Build Server Clone 跟 Checkout 的行為達到加速建置的效果。</p>
<p>可以參考：</p>
<ul>
<li><a href="https://www.peterdavehello.org/2015/05/use-git-sparse-checkout-and-shallow-clone-pull-to-increase-work-efficient/">善用 Git 的 sparse checkout 跟 shallow clone/pull 來提高工作效率</a> by Peter Dave</li>
</ul>
<p>git 2.34 加入了更激進的 <a href="https://github.blog/2021-11-10-make-your-monorepo-feel-small-with-gits-sparse-index/">Sparse Index</a>，如果你是 Monorepo 式的專案可以連 index 都 sparse 取出。但我們目前沒有使用 Monorepo，個人也對 Monorepo 後再剔除東西回到好像非 Monorepo 的狀態的工作流程有點疑惑，就先不延伸討論。</p>
<h1 id="branching-model">Branching Model</h1>
<p>先前流行過的 <a href="https://nvie.com/posts/a-successful-git-branching-model/">Git Flow</a> （<a href="https://gitbook.tw/chapters/gitflow/why-need-git-flow.html">Git Flow 是什麼？為什麼需要這種東西？</a>）在使用過許久之後決定棄用，它帶來的好處沒有大過它的複雜度帶來的困擾（<a href="https://news.ycombinator.com/item?id=22496724">Hacker News 討論</a>），尤其是在不完全是技術背景的遊戲團隊裡更是執行困難。</p>
<p>另外 Git Flow 沒有特別強調 Feature Branch 生命週期必須短或是必須頻繁地向主要分支合併。如果有長的 Feature Branch 就是沒有整合 （Integration）。<strong>開長的 Feature Branch 並不會帶給你獨立工作的環境，只是獨立工作的假象</strong>。它的真正效果是延遲支付整合的成本，但是到整合的時候就是連本帶利的吐出來。如果有遇過在 Sprint 或是 Milestone 快結束前好幾個人想 Merge 主幹分支互相衝突到死，還有硬是 Merge 後主幹分支上的程式穩定度大爆炸又沒有時間修的情境就知道我的意思。</p>
<p>現在開始往 <a href="https://trunkbaseddevelopment.com/">Trunk-Based Development</a> 過渡，開短的 Feature Branch 快速往主要分支合併，或是長的 Feature Branch 但是用 <a href="https://martinfowler.com/bliki/BranchByAbstraction.html">Branch by Abstraction</a> 和 <a href="https://www.martinfowler.com/articles/feature-toggles.html">Feature Toggles</a> 讓未完成的功能還是能定期合併進主要分支又不影響其他人，由此把整合的成本分攤開來。如果有在跑 Scrum 有時會遇到功能在 Sprint 結束的時候還收不了尾，如果都放在很久沒合併過的 Feature Branch 上就這樣帶到下一個 Sprint 會非常困擾，所以變成在 Sprint 尾聲非得整合進去的壓力很大。如果功能是 Feature Toggles 控制的話就可以有一個小段落就合併，下個 Sprint 開始再重新評估規畫即可。然後 Feature 完成之後一般是清除掉 Toggle，但也有沿用 Toggle 的結構做成 A/B Test 或是 Remote Config 的可能。</p>
<p>另外 Code Review 也是在頻繁合併發 Merge Request 的環境比較適合做，一般人一次能 Review 的程式長度其實有限。開發超過一週的改動份量 Review 起來就會非常吃力，更久就是折磨 Reviewer 了。</p>
<h1 id="lfs-lock">LFS Lock</h1>
<p>在 git LFS v2.0.0 新增了 <a href="https://github.com/git-lfs/git-lfs/wiki/File-Locking">鎖定</a> 特定檔案的功能，新版的 Fork 也支援從 UI 執行 LFS Lock。在 <code>.gitattributes</code> 加入 <code>lockable</code> 即宣告為可以鎖定的檔案：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">*.jpg filter=lfs diff=lfs merge=lfs -text lockable
</span></span></code></pre></td></tr></table>
</div>
</div><p>之後便可以用 lock 與 unlock</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git lfs lock &lt;檔案路徑&gt;
</span></span><span class="line"><span class="cl">git lfs unlock &lt;檔案路徑&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>雖然這個功能感覺可以實作類似 Perforce 的 Checkout 同時鎖定檔案功能，但是目前還是需要靠手動檢查 Lock 狀態，不是很方便。所以沒有推廣到專案上，但是覺得是一個有潛力的方向。<del>希望之後的版本能改進，或是有方法靠 Hook 兜出像是 Perforce 偵測到檔案編輯就自動上鎖的功能。</del></p>
<p>後來試了一下希望自動將檔案設定唯讀，然後在 LFS Lock 時才解除檔案唯讀的仿效 Perforce 的工作流程的自動化。實作到一半發現 <a href="https://forum.unity.com/threads/why-does-unity-unlock-a-read-only-file.35462/#post-230437">Unity Editor 本身就不會尊重系統上的唯讀 Flag</a>，因為 Unity 會隨便解除 Assets 目錄下檔案的唯讀，無法區分是我解鎖的還是 Unity 解鎖的。這樣只能放棄這個想法，也會讓我好奇 Perforce 要怎麼用在 Unity 上，還是無法做好整合？</p>
<p>另外 <a href="https://github.com/git-lfs/git-lfs/issues/3637">Per-branch Lock</a> 跟 <a href="https://github.com/git-lfs/git-lfs/issues/2671#issuecomment-349458133">Auto Unlock</a> 這兩個使用者期望能實作的改進好像就放置了，感覺這幾個大問題解決前好像沒有繼續投資研究 LFS Lock 的必要。</p>
<h1 id="vfs-for-git">VFS for Git</h1>
<p><a href="https://vfsforgit.org/">VFS for Git</a> 是微軟為了使用 git 管理 Windows 這個歷史悠久又巨大的 Repo 而提出的方案。底層是依賴 <a href="https://docs.microsoft.com/zh-tw/windows/win32/projfs/projected-file-system">ProjFS</a> 虛擬檔案系統，使用起來會看到 <code>gvfs clone</code> 時檔案存在在硬碟上但是沒有內容，一嘗試打開讀檔的 Blocking 就會包含從 Server 下載這段。測試 <code>gvfs clone</code> 的時候真的如同微軟宣稱的非常高速，在一分鐘內結束。實際的內容在 Unity 專案開啟時才會自動下載 HEAD Worktree 的內容，因為是檔案系統層的介入，Unity 2020 以後不用任何修改就能使用。但是因為 Unity 每次開啟都會掃描整個 <code>/Assets/</code> 資料夾建立 AssetDatabase，等於最後還是把整個 <code>/Assets/</code> 都摸過一遍抓下來。如果有引擎是只碰編輯有需要的檔案的系統，才能完整享受要用才抓的好處吧。</p>
<figure class="center"><img src="/images/unity-git/vfs-for-git-windows.png"/><figcaption>
            <h4>即使微軟宣稱 Windows repo 很大</h4>
        </figcaption>
</figure>

<figure class="center"><img src="/images/unity-git/spider-man.png"/><figcaption>
            <h4>老實說跟遊戲比起來還是感覺不大</h4>
        </figcaption>
</figure>

<p>雖然看起來很厲害但是現階段應該還是不會考量導入，最主要就是支援的 git Server 太少了。只有 Azure Repos 支援，然後 Repo 又有 <a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/limits?view=azure-devops#repository-size">250GB 大小限制</a>。有限制在還是會有點擔心。<a href="https://github.com/microsoft/VFSForGit/issues/1640#issuecomment-590880312">GitHub</a> 跟 <a href="https://gitlab.com/gitlab-org/gitlab-foss/-/issues/27895">GitLab</a> 看起來沒有積極想要支援的感覺。</p>
<p>如果還是有興趣的人想嘗試，導入時有幾個點要注意：</p>
<ul>
<li>只有 Azure Repos 支援。</li>
<li>git Repo 必須是非 LFS 狀態，已經是 LFS 的專案要反向做 <code>git lfs migrate export</code> 恢復到 Binary 都直接 Commit 在 git 歷史上的狀態。</li>
<li><code>.gitattribute</code> 內容要用 Rebase 從歷史刪除，只留 <code>* -text</code>，VFS for Git 不允許任何 <a href="https://github.com/microsoft/VFSForGit#trying-out-vfs-for-git"><code>.gitattribute</code> 轉換</a>。</li>
<li>git Client 必須要使用微軟的 <a href="https://github.com/microsoft/git">Fork</a>，微軟宣稱就算不用 VFS for Git，一般的 git 操作也能用這個 Fork 獲得一些加速。不過我後來遇到有些不太確定原因的現象，實驗完 VFS for Git 還是回去用 GUI Client 內建的版本。</li>
</ul>
<h1 id="single-source-of-truth">Single Source of Truth</h1>
<p>因為我們曾經是用 Mercurial 來管理專案，所以在導入 git 時有一段時間是程式們改用 git 而美術們繼續用慣用的 Mercurial，用腳本定時複製同步兩邊的改動。結果追查改動難度變超高，要不斷找同步的時間點然後跳到另一邊繼續追查歷史。在急著要出 Hotfix 的時候特別歡樂。後來受不了強制所有成員都改用 git，也因為這樣所以才會有上面為非技術人員 Survey 用戶端的故事。</p>
<p>這個經驗讓我覺得構成一個遊戲的資料應該放在同一個歷史，即同一個 Repo 下。所以也打消了 Survey 一些跨版本控制系統同步工具像是 <a href="https://www.perforce.com/perforce/r15.3/manuals/git-fusion/">Git Fusion</a> 或是 <a href="https://git-scm.com/docs/git-svn">git-svn</a> 的念頭。變成都用 git，然後儘量解決非技術人員的痛點。同時也漸漸少用 <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">git submodule</a>，要同步 Submoudle 跟外面的 Repo 的歷史太容易出錯。共用的工具庫現在走回最傳統的上 Tag 上版號出安裝包讓各專案安裝，各專案把工具內容直接 Commit 進各自的 Repo。</p>
<p>構成一個遊戲的資料應該放在同一個歷史的想法繼續推展下去，Server 的原始碼與企劃數值表也都該跟 Client 專案放同一個 Repo。當遊戲資料格式需要改動的時候，一個 Commit 包含 Server、Client、數值表三者的同步更新（Schema 使用類似 ProtoBuf 之類的跨語言定義），徹底解決 Server、Client 與數值資料 Schema 不同步造成的問題。但是苦於數值沒有現成好的編輯工具，企劃還是得在 Google Sheets 上編輯然後下載下來，所以這個想法還是一直處於我自己的空想階段。</p>
<p>關於數值編輯工具的討論，可以參考：</p>
<ul>
<li><a href="https://blog.demofox.org/2016/04/01/game-development-needs-data-pipeline-middleware/">Game Development Needs Data Pipeline Middleware</a></li>
</ul>
<h1 id="為什麼要用-git">為什麼要用 git？</h1>
<p>其實開啟 LFS 或 VFS for Git 就減損了 git 分散式的特性，使用 Thunk-based 對於 Branch 能力的需求就降低不少，然後現在我們試圖在 LFS 上面開啟 Lock。也會有很多人問說為什麼不乾脆用 SVN、Perforce，在這篇文章草稿討論時也有幾位開發者朋友提到他們改用 <a href="https://www.plasticscm.com/">Plastic</a>。我想了很久想不太到一個好的答案，git 在設計時應該是沒有把遊戲開發常見的大檔案、無法合併的 Binary 使用情境考慮進去，現在是用 LFS 外掛在 Smudge / Clean 系統上湊出來的。而這篇文章很大一部分其實也是在處理這種外掛作法衍生的問題。當初公司從 Mercurial 搬到 git，單純是感覺到 Mercurial 的開發動能比 git 少很多，像是 Merge Request 接到 Code Review 的工具 Mercurial 當時找不太到適用的，而 git 有 Gerrit、GitHub 跟後來我們在用的 GitLab。git 用戶端也是推陳出新，而 Mercurial 就是那幾種。所以這是 <a href="http://dreamsongs.com/WorseIsBetter.html">Worse is better</a> 裡面所說 Worse 的勝利嗎？也許是（不是說 Mercurial 就是 Better，老實說我也不知道這個問題的 Better 是什麼）。</p>
<p>我想至少不管是什麼原因你選擇了用 git 版本控制你的 Unity 專案，至少我可以提供一些經驗與協助。我沒有覺得非用 git 不可，如果你有更喜歡的做法也很好，然後歡迎分享你的經驗。如果沒有想法的話可能就使用者多的地方資源多些，踩坑的隊友也多些。</p>
<p>希望這篇文章能讓洗了 git 頭的大家少跟 git 搏鬥一分，開發遊戲多一分。有機會再見。</p>
<h1 id="鳴謝">鳴謝</h1>
<p>感謝 Review 過這篇文章草稿給過建議的包子、小善學長、小金學長、Hugo、建豪、蒼時、頭皮、Colin、于修、Denny、
JohnSu、Recca、Jonas 與各位朋友們。如果有想要補充討論的也歡迎留言。</p>

  </div>
</article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="FrankNine/franknine.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="FrankNine" class="iconfont icon-thub" title="thub"></a>
      <a href="aaefiikmnnnr" class="iconfont icon-itter" title="itter"></a>
  <a href="https://franknine.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2010 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>Chun-Fu Chao</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-BP1PMVB7ZQ', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
